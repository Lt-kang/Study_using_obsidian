---
id: -1
subject: 1-1. Learn the basics
last_synced: ""
book_id: 17765
parent_id: 283804
---
src: https://langchain-ai.github.io/langgraph/tutorials/introduction/

# ğŸš€ LangGraph Quickstart

í•´ë‹¹ íŠœí† ë¦¬ì–¼ì—ì„œëŠ” LangGraphë¥¼ í†µí•´ chatbotì„ ë§Œë“­ë‹ˆë‹¤.  
LangGraphëŠ” ì•„ë˜ì™€ ê°™ì€ ê¸°ëŠ¥ì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤.

âœ… Answer common questions by searching the web  
âœ… Maintain conversation state across calls  
âœ… Route complex queries to a human for review  
âœ… Use custom state to control its behavior  
âœ… Rewind and explore alternative conversation paths  


í•´ë‹¹ íŠœí† ë¦¬ì–¼ì„ í†µí•´ ê¸°ë³¸ì ì¸ chatbotì„ ë§Œë“¤ë©´ì„œ
LangGraphì˜ ì»¨ì…‰ì„ ì´í•´í•˜ëŠ” ê²ƒì„ ê¸°ëŒ€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

___

## Setup
ë¨¼ì €, í™˜ê²½ì„¤ì • ë° íŠœí† ë¦¬ì–¼ ì§„í–‰ì— í•„ìš”í•œ python packageë¥¼ ì„¤ì¹˜í•©ë‹ˆë‹¤.
> í•´ë‹¹ íŠœí† ë¦¬ì–¼ì€ ANTHROPIC_APIê°€ í•„ìš”í•©ë‹ˆë‹¤.   
> ë‹¨, LLMì€ ë‹¤ë¥¸ ê²ƒìœ¼ë¡œ ëŒ€ì²´ê°€ ê°€ëŠ¥í•˜ë‹ˆ ë³¸ì¸ì´ ê°€ì§„ api keyì— ë§ê²Œ llmì„ ì„ ì–¸í•˜ì—¬ ì‚¬ìš©í•˜ì‹œê¸¸ ë°”ëë‹ˆë‹¤.  

```
%%capture --no-stderr
%pip install -U langgraph langsmith "langchain[anthropic]"
```

```
import getpass
import os


def _set_env(var: str):
    if not os.environ.get(var):
        os.environ[var] = getpass.getpass(f"{var}: ")


_set_env("ANTHROPIC_API_KEY")
```
>**LangGraph ê°œë°œì„ ìœ„í•´ [LangSmith](https://smith.langchain.com/)ë¥¼ ì„¤ì¹˜í•˜ì„¸ìš”.**  
LangSmithì— ê°€ì…í•˜ì—¬ LangGraph í”„ë¡œì íŠ¸ì˜ ë¬¸ì œë¥¼ ë°œê²¬í•˜ê³  ì„±ëŠ¥ì„ ê°œì„ í•˜ì„¸ìš”.  
LangSmithëŠ” LangGraph í”„ë¡œì íŠ¸ì— ì‚¬ìš©ëœ LLMì— ëŒ€í•´ debug, test, monitorë¥¼ ìœ„í•œ ë°ì´í„° ì¶”ì ì„ ì§€ì›í•©ë‹ˆë‹¤.  
LangSmithì— ëŒ€í•´ ë” ë°°ìš°ê³  ì‹¶ë‹¤ë©´ [ì—¬ê¸°](https://docs.smith.langchain.com/)ë¥¼ ëˆ„ë¥´ì„¸ìš”.  

<br>

___

## Part 1: ê¸°ë³¸ì ì¸ Chatbot êµ¬ì¶•í•˜ê¸°
ê°€ì¥ ë¨¼ì € LangGraphë¥¼ í†µí•œ ê°„ë‹¨í•œ chatbotì„ ë§Œë“¤ì–´ë³¼ê²ë‹ˆë‹¤.  
ì´ chatbotì€ ì‚¬ìš©ìì˜ messagesì— ê³§ë°”ë¡œ ì‘ë‹µí•©ë‹ˆë‹¤.  
ì •ë§ ê°„ë‹¨í•´ë³´ì´ì§€ë§Œ ì´ëŠ” LangGraphì˜ ì¤‘ìš”í•œ íŠ¹ì§•ì„ ë³´ì—¬ì¤ë‹ˆë‹¤.  
ì´ ì±•í„°ë¥¼ ëê¹Œì§€ ë”°ë¼ì˜¤ì‹ ë‹¤ë©´, ë‹¹ì‹ ì€ ê¸°ë³¸ì ì¸ chatbotì„ í›Œë¥­íˆ ë§Œë“¤ì–´ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.


LangGraphëŠ” `StateGraph`ë¡œ ë¶€í„° ì‹œì‘í•©ë‹ˆë‹¤.  
`StateGraph` ê°ì²´ëŠ” chatbot êµ¬ì¡°ë¥¼ "state machine"ìœ¼ë¡œ ì •ì˜í•©ë‹ˆë‹¤.  
ë˜í•œ `nodes` ê°ì²´ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.  
`nodes`ê°ì²´ëŠ” llmê³¼ chatbotì„ í˜¸ì¶œí•  ìˆ˜ ìˆëŠ” í•¨ìˆ˜ ë“±ì„ ì˜ë¯¸í•©ë‹ˆë‹¤.  
ë§ˆì§€ë§‰ìœ¼ë¡œ `edges`ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.  
`edges`ëŠ” chatbotì´ `nodes`ì—ì„œ ì´í›„ ì–´ë””ë¡œ ì´ë™í•´ì•¼í• ì§€ ì •ì˜í•˜ëŠ” ê°ì²´ ì…ë‹ˆë‹¤.  

`StateGraph`: ì‹œì‘ì 
`nodes`: ë¶„ê¸°ì 
`edges`: `nodes`ì—ì„œ llm&chatbotì´ ì–´ë””ë¡œ ì´ë™í• ì§€ ì •ì˜í•˜ëŠ” point

API Reference: [StateGraph](https://langchain-ai.github.io/langgraph/reference/graphs/#langgraph.graph.state.StateGraph) | [START](https://langchain-ai.github.io/langgraph/reference/constants/#langgraph.constants.START) | [END](https://langchain-ai.github.io/langgraph/reference/constants/#langgraph.constants.END) | [add_messages](https://langchain-ai.github.io/langgraph/reference/graphs/#langgraph.graph.message.add_messages)
```
from typing import Annotated

from typing_extensions import TypedDict

from langgraph.graph import StateGraph, START, END
from langgraph.graph.message import add_messages


class State(TypedDict):
    # Messages have the type "list". The `add_messages` function
    # in the annotation defines how this state key should be updated
    # (in this case, it appends messages to the list, rather than overwriting them)
    messages: Annotated[list, add_messages]


graph_builder = StateGraph(State)
```

ìœ„ graphì—ì„œ 2ê°€ì§€ ì‘ì—…ì„ ì œì–´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
1. ê° `node`ëŠ” `State`ë¥¼ inputìœ¼ë¡œ ë°›ì„ ìˆ˜ ìˆìœ¼ë©° `State`ë¥¼ updateí•˜ì—¬ outputìœ¼ë¡œ ì¶œë ¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
2. messagesëŠ” updateë˜ë©´ì„œ ë®ì–´ì”Œì›Œì§€ëŠ”ê²Œ ì•„ë‹ˆë¼ listì— ì¶”ê°€ê°€ ë  ê²ƒì…ë‹ˆë‹¤. ì´ëŠ” `Annotated` ë¬¸ë²•ì— `add_messages` ë©”ì†Œë“œê°€ ë¯¸ë¦¬ ë§Œë“¤ì–´ì ¸ìˆê¸° ë•Œë¬¸ ì…ë‹ˆë‹¤.  

<br>

>**Concept**  
graphë¥¼ ì •ì˜í•  ë•Œ ê°€ì¥ ì²«ë²ˆì§¸ë¡œ `State`ë¥¼ ì •ì˜í•©ë‹ˆë‹¤. `State`ëŠ” graphì˜ ë„ì‹ì„ í¬í•¨í•˜ê³  ìˆìœ¼ë©° `State`ë¥¼ updateí•  ìˆ˜ ìˆëŠ” [reducer functions](https://langchain-ai.github.io/langgraph/concepts/low_level/#reducers)ë„ í•¨ê²Œ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤.  
ìœ„ ì˜ˆì‹œë¥¼ í†µí•´ ì„¤ëª…í•˜ìë©´, `State`ëŠ” `TypeDict` classë¥¼ ìƒì† ë°›ì•˜ìœ¼ë©° `messages` instanceë¥¼ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤.  
`add_messages` reducer í•¨ìˆ˜ëŠ” new messageë¥¼ ë®ì–´ ì‹€ìš°ëŠ”ê²Œ ì•„ë‹Œ listì— ì¶”ê°€í•˜ê¸° ìœ„í•´ ì‚¬ìš©ë©ë‹ˆë‹¤.  
í•µì‹¬ì€ annotation ì—†ëŠ” recuderëŠ” ê¸°ì¡´ valueë¥¼ ë®ì–´ ì”Œê²Œ ëœë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤.  
state, reducer ê·¸ë¦¬ê³  ì—°ê´€ëœ ì»¨ì…‰ì„ ë” ë°°ìš°ê³  ì‹¶ë‹¤ë©´ [thist guide](https://langchain-ai.github.io/langgraph/reference/graphs/#langgraph.graph.message.add_messages)ë¥¼ ì°¸ê³ í•´ì£¼ì„¸ìš”.  


ë‹¤ìŒìœ¼ë¡œëŠ” `chatbot` nodeë¥¼ ì¶”ê°€í•´ë³´ë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤.
nodeë“¤ì€ ê° ì‘ì—… ë‹¨ìœ„ë¥¼ ì˜ë¯¸í•˜ë©° í‰ë²”í•œ python functionìœ¼ë¡œ ë§Œë“¤ì–´ì§‘ë‹ˆë‹¤. 

API Reference: [init_chat_model](https://python.langchain.com/api_reference/langchain/chat_models/langchain.chat_models.base.init_chat_model.html)

```
from langchain.chat_models import init_chat_model

llm = init_chat_model("anthropic:claude-3-5-sonnet-latest")


def chatbot(state: State):
    return {"messages": [llm.invoke(state["messages"])]}


# The first argument is the unique node name
# The second argument is the function or object that will be called whenever
# the node is used.
graph_builder.add_node("chatbot", chatbot)
```

**Notice** í•´ë‹¹ ì„¹ì…˜ì—ì„œëŠ” `chatbot` node í•¨ìˆ˜ê°€ ì–´ë–»ê²Œ `State`ë¥¼ ì…ë ¥ìœ¼ë¡œ ë°›ê³  ë‹¤ì‹œ dictionary typeìœ¼ë¡œ returnì„ í•˜ë©°, `messages`ë¥¼ updateí•˜ëŠ”ì§€ì— ëŒ€í•´ ì„¤ëª…í•©ë‹ˆë‹¤. ì´ëŸ¬í•œ íŒ¨í„´ì€ LangGraph node í•¨ìˆ˜ì—ì„œ ì¼ë°˜ì ì¸ íŒ¨í„´ ì…ë‹ˆë‹¤.

`State`ê°ì²´ì—ì„œ ì‚¬ìš©ë˜ëŠ” `add_messages` ë©”ì„œë“œëŠ” ê¸°ì¡´ stateì— messageì— (ì–´ë–¤ messageê°€ ìˆë“  ê°„ì—) llmì˜ ì‘ë‹µ messagesì— ì¶”ê°€ í•©ë‹ˆë‹¤.

ë‹¤ìŒìœ¼ë¡œëŠ” `entry`pointë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.  
`entry` pointëŠ” ìš°ë¦¬ê°€ ë§Œë“¤ê³  ìˆëŠ” graphê°€ ì–´ë””ì„œ ì‹œì‘í•˜ëŠ”ì§€ ì•Œë ¤ì¤ë‹ˆë‹¤.
```
graph_builder.add_edge(START, "chatbot")
```

ìœ„ì™€ ë¹„ìŠ·í•˜ê²Œ `finish`pointëŠ” graphê°€ ì–´ë””ì„œ ì¢…ë£Œë˜ëŠ”ì§€ ì•Œë ¤ì¤ë‹ˆë‹¤.
```
graph_builder.add_edge("chatbot", END)
```

ë§ˆì§€ë§‰ìœ¼ë¡œ, `compile()`í•¨ìˆ˜ëŠ” ì§€ê¸ˆê¹Œì§€ ë§Œë“  ìš°ë¦¬ì˜ graphê°€ ì‘ë™ ê°€ëŠ¥í•˜ë„ë¡ ë§Œë“­ë‹ˆë‹¤.  
í•´ë‹¹ í•¨ìˆ˜ëŠ” `CompiledGraph`ë¥¼ ë°˜í™˜í•˜ë©° ìš°ë¦¬ëŠ” ì´ì œë¶€í„° ì´ `CompiledGraph`ì— invokeí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
```
graph = graph_builder.compile()
```

`get_graph`ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ë©´ ì—¬ëŸ¬ë¶„ì´ ë§Œë“  graphë¥¼ ì‹œê°í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
* `get_graph`: `draw_ascii`, `draw_png`ì™€ ê°™ì€ ì‹œê°í™” ë©”ì†Œë“œ ì¤‘ í•˜ë‚˜
* ì‹œê°í™” ë©”ì„œë“œëŠ” ê°ê°ì˜ ì¶”ê°€ì ì¸ ì˜ì¡´ì„± íŒ¨í‚¤ì§€ ì„¤ì¹˜ë¥¼ í•„ìš”ë¡œ í•œë‹¤.
```
from IPython.display import Image, display

try:
    display(Image(graph.get_graph().draw_mermaid_png()))
except Exception:
    # This requires some extra dependencies and is optional
    pass
```

![[figure1.png]]

ì´ì œ chatbotì„ ì‹¤í–‰í•´ë³´ì‹¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤!

**Tip**: "quit", "exit", "q"ì™€ ê°™ì€ ì…ë ¥ìœ¼ë¡œ chat bot ëŒ€í™”ë¥¼ ì¢…ë£Œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. (ì•„ë˜ ì˜ˆì‹œ ì½”ë“œ ì°¸ê³ )
```
def stream_graph_updates(user_input: str):
    for event in graph.stream({"messages": [{"role": "user", "content": user_input}]}):
        for value in event.values():
            print("Assistant:", value["messages"][-1].content)


while True:
    try:
        user_input = input("User: ")
        if user_input.lower() in ["quit", "exit", "q"]:
            print("Goodbye!")
            break
        stream_graph_updates(user_input)
    except:
        # fallback if input() is not available
        user_input = "What do you know about LangGraph?"
        print("User: " + user_input)
        stream_graph_updates(user_input)
        break
```
```
Assistant: LangGraph is a library designed to help build stateful multi-agent applications using language models. It provides tools for creating workflows and state machines to coordinate multiple AI agents or language model interactions. LangGraph is built on top of LangChain, leveraging its components while adding graph-based coordination capabilities. It's particularly useful for developing more complex, stateful AI applications that go beyond simple query-response interactions.
Goodbye!
```

**ì¶•í•˜í•©ë‹ˆë‹¤.**  
ë‹¹ì‹ ì€ LangGraphë¥¼ í†µí•œ ì²« chatbotì„ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤.  
í•´ë‹¹ chatbotì€ ì‚¬ìš©ìì˜ inputì„ ì…ë ¥ ë°›ì•„ì„œ LLMìœ¼ë¡œë¶€í„° ë‹µë³€ì„ ë°˜í™˜í•´ì£¼ëŠ” ê¸°ë³¸ì ì¸ ëŒ€í™” ëŠ¥ë ¥ì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤.  
ë˜í•œ [LangSmith Trace ë§í¬](https://smith.langchain.com/public/7527e308-9502-4894-b347-f34385740d5a/r)ì— ì ‘ì†í•´ë³´ì‹œë©´ LangSmithë¡œ ì•ì„œ í˜¸ì¶œí•œ ë‚´ìš©ì— ëŒ€í•œ Traceë¥¼ í™•ì¸í•´ë³´ì‹¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.


### Full Code
API Reference: [init_chat_model](https://python.langchain.com/api_reference/langchain/chat_models/langchain.chat_models.base.init_chat_model.html) | [StateGraph](https://langchain-ai.github.io/langgraph/reference/graphs/#langgraph.graph.state.StateGraph) | [add_messages](https://langchain-ai.github.io/langgraph/reference/graphs/#langgraph.graph.message.add_messages)
```
from typing import Annotated

from langchain.chat_models import init_chat_model
from typing_extensions import TypedDict

from langgraph.graph import StateGraph
from langgraph.graph.message import add_messages


class State(TypedDict):
    messages: Annotated[list, add_messages]


graph_builder = StateGraph(State)


llm = init_chat_model("anthropic:claude-3-5-sonnet-latest")


def chatbot(state: State):
    return {"messages": [llm.invoke(state["messages"])]}


# The first argument is the unique node name
# The second argument is the function or object that will be called whenever
# the node is used.
graph_builder.add_node("chatbot", chatbot)
graph_builder.set_entry_point("chatbot")
graph_builder.set_finish_point("chatbot")
graph = graph_builder.compile()
```

<br>

___

## Part 2: ğŸ› ï¸ Toolsë¥¼ ì‚¬ìš©í•˜ì—¬ Chatbot ì„±ëŠ¥ í–¥ìƒí•˜ê¸°

chatbotì´ ë³¸ì¸ì˜ ê¸°ì–µ ë§Œìœ¼ë¡œ ë‹µí•˜ì§€ ëª»í•˜ëŠ” ì§ˆë¬¸ì„ ì²˜ë¦¬í•˜ê¸° ìœ„í•´, 
ìš°ë¦¬ëŠ” ì›¹ ê²€ìƒ‰ toolì„ chatbotì— ì¶”ê°€í• ê²ë‹ˆë‹¤.  
ìš°ë¦¬ê°€ ë§Œë“  chatbotì´ í•´ë‹¹ toolì„ ì‚¬ìš©í•œë‹¤ë©´, 
ì›¹ì—ì„œ ê´€ë ¨ëœ ì •ë³´ë¥¼ ì°¾ê³ , ë” í›Œë¥­í•œ ë‹µë³€ìœ¼ë¡œ ì‘ë‹µí• ê²ƒì…ë‹ˆë‹¤. 

### í•„ìš”í•œ ì¤€ë¹„ë¬¼ë“¤

ì‹œì‘í•˜ê¸° ì´ì „ ì›¹ ê²€ìƒ‰ toolì— ì‚¬ìš©ë  api keyì™€ ì¶”ê°€ packageë“¤ì„ ì„¤ì¹˜í•´ì•¼ í•©ë‹ˆë‹¤.

ë¨¼ì €, [Tavily Search Engine](https://python.langchain.com/docs/integrations/tools/tavily_search/)ì„ ì„¤ì¹˜í•œ ë’¤   [TAVILY_API_KEY](https://tavily.com/)ë¥¼ ì„¤ì •í•´ì¤ë‹ˆë‹¤.
```
%%capture --no-stderr
%pip install -U langchain-tavily
```
```
_set_env("TAVILY_API_KEY")
```
```
TAVILY_API_KEY:  YOUR_API_KEY
```

ì´í›„ chatbotì´ ì‚¬ìš©í•  toolì„ ì •ì˜í•´ì¤ë‹ˆë‹¤.

API Reference: [TavilySearch](https://python.langchain.com/api_reference/tavily/tavily_search/langchain_tavily.tavily_search.TavilySearch.html)

```
from langchain_tavily import TavilySearch

tool = TavilySearch(max_results=2)
tools = [tool]
tool.invoke("What's a 'node' in LangGraph?")
```
```
{'query': "What's a 'node' in LangGraph?",
 'follow_up_questions': None,
 'answer': None,
 'images': [],
 'results': [{'title': "Introduction to LangGraph: A Beginner's Guide - Medium",
   'url': 'https://medium.com/@cplog/introduction-to-langgraph-a-beginners-guide-14f9be027141',
   'content': 'Stateful Graph: LangGraph revolves around the concept of a stateful graph, where each node in the graph represents a step in your computation, and the graph maintains a state that is passed around and updated as the computation progresses. LangGraph supports conditional edges, allowing you to dynamically determine the next node to execute based on the current state of the graph. We define nodes for classifying the input, handling greetings, and handling search queries. def classify_input_node(state): LangGraph is a versatile tool for building complex, stateful applications with LLMs. By understanding its core concepts and working through simple examples, beginners can start to leverage its power for their projects. Remember to pay attention to state management, conditional edges, and ensuring there are no dead-end nodes in your graph.',
   'score': 0.7065353,
   'raw_content': None},
  {'title': 'LangGraph Tutorial: What Is LangGraph and How to Use It?',
   'url': 'https://www.datacamp.com/tutorial/langgraph-tutorial',
   'content': 'LangGraph is a library within the LangChain ecosystem that provides a framework for defining, coordinating, and executing multiple LLM agents (or chains) in a structured and efficient manner. By managing the flow of data and the sequence of operations, LangGraph allows developers to focus on the high-level logic of their applications rather than the intricacies of agent coordination. Whether you need a chatbot that can handle various types of user requests or a multi-agent system that performs complex tasks, LangGraph provides the tools to build exactly what you need. LangGraph significantly simplifies the development of complex LLM applications by providing a structured framework for managing state and coordinating agent interactions.',
   'score': 0.5008063,
   'raw_content': None}],
 'response_time': 1.38}
```

ìœ„ ê²°ê³¼(TavilySearchì˜ ê²°ê³¼)ëŠ” chatbotì´ ì§ˆë¬¸ì— ëŒ€í•œ ë‹µë³€ì„ ì¶œë ¥í•˜ëŠ”ë° ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì´í›„ëŠ” LLM(chatbotì— ì‚¬ìš©í•˜ëŠ”)ì— `bind_tools`ì„ ì¶”ê°€í•´ì•¼í•©ë‹ˆë‹¤. (ê·¸ ì™¸ì—ëŠ” Part 1ì—ì„œ í–ˆë˜ ê²ƒê³¼ ë™ì¼í•¨.)  
ì´ëŸ¬í•œ ì¶”ê°€ëŠ” LLMì´ search engine(TavilSearch)ì„ ì‚¬ìš©í•  ë•Œ, LLMì´ ì •í™•í•œ JSON í¬ë§·ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ë„ì™€ì¤ë‹ˆë‹¤.


API Reference: [init_chat_model](https://python.langchain.com/api_reference/langchain/chat_models/langchain.chat_models.base.init_chat_model.html) | [StateGraph](https://langchain-ai.github.io/langgraph/reference/graphs/#langgraph.graph.state.StateGraph) | [START](https://langchain-ai.github.io/langgraph/reference/constants/#langgraph.constants.START) | [END](https://langchain-ai.github.io/langgraph/reference/constants/#langgraph.constants.END) | [add_messages](https://langchain-ai.github.io/langgraph/reference/graphs/#langgraph.graph.message.add_messages)

```
from typing import Annotated

from langchain.chat_models import init_chat_model
from typing_extensions import TypedDict

from langgraph.graph import StateGraph, START, END
from langgraph.graph.message import add_messages


class State(TypedDict):
    messages: Annotated[list, add_messages]


graph_builder = StateGraph(State)


llm = init_chat_model("anthropic:claude-3-5-sonnet-latest")
# Modification: tell the LLM which tools it can call
llm_with_tools = llm.bind_tools(tools)


def chatbot(state: State):
    return {"messages": [llm_with_tools.invoke(state["messages"])]}


graph_builder.add_node("chatbot", chatbot)
```

ë‹¤ìŒìœ¼ë¡œ, ìš°ë¦¬ëŠ” í•¨ìˆ˜(LLMì´ í˜¸ì¶œí•˜ì—¬ ì‚¬ìš©í•  tool)ì„ ë§Œë“¤ì–´ì•¼ í•©ë‹ˆë‹¤.  
ë§Œë“  í•¨ìˆ˜ëŠ” ìƒˆë¡œìš´ nodeì— ì¶”ê°€í•´ë³´ë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤.

ì•„ë˜ ë‚´ìš©ì€, ìµœê·¼ messageë¥¼ í™•ì¸í•˜ê³  messageì— toolì„ í˜¸ì¶œí•˜ë¼ëŠ” ë‚´ìš©ì´ ìˆë‹¤ë©´ í•´ë‹¹ toolì„ í˜¸ì¶œí•˜ëŠ” `BasicToolNode`ë¥¼ ì‚¬ìš©í•´ë³¼ê²ƒì…ë‹ˆë‹¤.
ì•„ë˜ ë‚´ìš©ì€, ìµœê·¼ messageë¥¼ í™•ì¸í•˜ê³  í•´ë‹¹ messageì— `tool_calls`ê°€ í¬í•¨ë˜ì–´ ìˆë‹¤ë©´ toolì„ í˜¸ì¶œí•˜ëŠ” ê¸°ëŠ¥ì¸ `BasicToolNode`ì— ëŒ€í•´ ì•Œì•„ë³¼ ì˜ˆì •ì…ë‹ˆë‹¤.
í•´ë‹¹ ê¸°ëŠ¥ì€ ì‚¬ìš©í•˜ëŠ” LLMì´ `tool_calling`ê¸°ëŠ¥ì„ ì§€ì›í•´ì•¼ ì‚¬ìš©ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤. (Anthropic, OpenAI, google Geminië¥¼ í¬í•¨í•œ ê¸°íƒ€ LLM) 


ì´í›„ì—ëŠ” LangGraphì—ì„œ ë¯¸ë¦¬ ë§Œë“¤ì–´ë‘” [ToolNode](https://langchain-ai.github.io/langgraph/reference/prebuilt/#toolnode)ë¡œ êµì²´í•˜ì—¬ ì‹¤í–‰ ì†ë„ë¥¼ ë†’í ì˜ˆì •ì´ì§€ë§Œ  
ì§€ê¸ˆì€ í•™ìŠµì„ ìœ„í•´ ì§ì ‘ êµ¬í˜„í•´ë³´ë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤.


API Reference: [ToolMessage](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.tool.ToolMessage.html)
```
import json

from langchain_core.messages import ToolMessage


class BasicToolNode:
    """A node that runs the tools requested in the last AIMessage."""

    def __init__(self, tools: list) -> None:
        self.tools_by_name = {tool.name: tool for tool in tools}

    def __call__(self, inputs: dict):
        if messages := inputs.get("messages", []):
            message = messages[-1]
        else:
            raise ValueError("No message found in input")
        outputs = []
        for tool_call in message.tool_calls:
            tool_result = self.tools_by_name[tool_call["name"]].invoke(
                tool_call["args"]
            )
            outputs.append(
                ToolMessage(
                    content=json.dumps(tool_result),
                    name=tool_call["name"],
                    tool_call_id=tool_call["id"],
                )
            )
        return {"messages": outputs}


tool_node = BasicToolNode(tools=[tool])
graph_builder.add_node("tools", tool_node)
```

tool nodeê°€ ì¶”ê°€ë˜ì—ˆìœ¼ë¯€ë¡œ, `conditional_edges`ë¥¼ ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ë‹¤ì‹œ ë˜ì§šì–´ë³´ìë©´, **edges**ëŠ” graphì˜ íŠ¹ì • nodeì—ì„œ ë‹¤ìŒ nodeë¡œ ì´ë™í•  íë¦„ì„ ì œì–´í•©ë‹ˆë‹¤.  
**Conditional edges**ëŠ” ì…ë ¥ ë°›ì€ graph stateë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë‹¤ë¥¸ nodeë¡œ ë³´ë‚´ê¸° ìœ„í•´ "if ë¬¸"ì„ í¬í•¨í•˜ë©°  
ë‹¤ìŒìœ¼ë¡œ ì´ë™í•  node ì •ë³´ë¥¼ ë‚˜íƒ€ë‚´ëŠ” string í˜¹ì€ listë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

ì•„ë˜ ë‚´ìš©ì€, chatbotì˜ ì¶œë ¥ì— tool_callsê°€ í¬í•¨ë˜ì–´ìˆëŠ”ì§€ í™•ì¸í•˜ëŠ” `route_tools`ì´ë¼ ë¶ˆë¦¬ëŠ” router í•¨ìˆ˜ë¥¼ ì •ì˜í•˜ëŠ” ë‚´ìš©ì…ë‹ˆë‹¤.  
ì´í›„ `add_conditional_edges`ë¥¼ í˜¸ì¶œí•˜ì—¬ ì´ í•¨ìˆ˜(route_tools)ë¥¼ graphì— ë“±ë¡í•©ë‹ˆë‹¤.
ì´ëŸ¬í•œ ì„¤ì •ì„ í†µí•´ chatbot nodeê°€ ì‹¤í–‰ì„ ë§ˆì¹  ë•Œë§ˆë‹¤, graphê°€ route_tools í•¨ìˆ˜ë¥¼ ì°¸ê³ í•˜ì—¬ ì´í›„ ì–´ë–¤ ë…¸ë“œë¡œ ì´ë™í• ì§€ íŒë‹¨í•˜ê²Œ ë©ë‹ˆë‹¤.  

ì´ ì¡°ê±´ì€ chatbot ì¶œë ¥ì— tool_callsê°€ ìˆë‹¤ë©´ graph stateë¥¼ `tools`ë¡œ ë³´ë‚´ê³  ê·¸ë ‡ì§€ ì•Šë‹¤ë©´ `END`ë¡œ ë³´ëƒ…ë‹ˆë‹¤.

ì´í›„ì—ëŠ” ì´ë¯¸ ë§Œë“¤ì–´ì ¸ìˆëŠ” ì¡°ê¸ˆ ë” ê°„ê²°í•œ `tools_condition` í•¨ìˆ˜ë¡œ ëŒ€ì²´í• ê²ë‹ˆë‹¤ë§Œ,
ì–´ë–»ê²Œ ì‘ë™í•˜ëŠ”ì§€ í•™ìŠµí•˜ê¸° ìœ„í•´ ì§ì ‘ ë§Œë“¤ì–´ë³´ê² ìŠµë‹ˆë‹¤.

```
def route_tools(
    state: State,
):
    """
    Use in the conditional_edge to route to the ToolNode if the last message
    has tool calls. Otherwise, route to the end.
    """
    if isinstance(state, list):
        ai_message = state[-1]
    elif messages := state.get("messages", []):
        ai_message = messages[-1]
    else:
        raise ValueError(f"No messages found in input state to tool_edge: {state}")
    if hasattr(ai_message, "tool_calls") and len(ai_message.tool_calls) > 0:
        return "tools"
    return END


# The `tools_condition` function returns "tools" if the chatbot asks to use a tool, and "END" if
# it is fine directly responding. This conditional routing defines the main agent loop.
graph_builder.add_conditional_edges(
    "chatbot",
    route_tools,
    # The following dictionary lets you tell the graph to interpret the condition's outputs as a specific node
    # It defaults to the identity function, but if you
    # want to use a node named something else apart from "tools",
    # You can update the value of the dictionary to something else
    # e.g., "tools": "my_tools"
    {"tools": "tools", END: END},
)
# Any time a tool is called, we return to the chatbot to decide the next step
graph_builder.add_edge("tools", "chatbot")
graph_builder.add_edge(START, "chatbot")
graph = graph_builder.compile()
```

**Notice** conditional_edgeëŠ” 1ê°œì˜ nodeë¡œë¶€í„° ì‹œì‘ë©ë‹ˆë‹¤.
ë˜í•œ graphê°€ ìƒì‹œ chatbot nodeê°€ ì‹¤í–‰ë  ë•Œë§ˆë‹¤, 
toolì„ í˜¸ì¶œí•˜ë©´ `tools`ë¡œ ì´ë™í•˜ê³ , (tool í˜¸ì¶œ ì—†ì´) ì§ì ‘ì ìœ¼ë¡œ ì‘ë‹µí•  ê²½ìš° `END`ë¡œ ì´ë™í•©ë‹ˆë‹¤.

ë¯¸ë¦¬ ë§Œë“¤ì–´ì§„ `tools_condition`ë©”ì„œë“œì²˜ëŸ¼, ìš°ë¦¬ê°€ ë§Œë“  í•¨ìˆ˜ë„ toolì„ í˜¸ì¶œí•˜ì§€ ì•ŠëŠ”ë‹¤ë©´ 
`END`nodeë¡œ ì´ë™í•©ë‹ˆë‹¤.
`END`nodeë¡œ ì´ë™í•  ë•Œ, ë”ì´ìƒ ì‘ì—…ì„ ìˆ˜í–‰í•˜ì§€ ì•Šìœ¼ë©° ì‹¤í–‰ì´ ì¤‘ë‹¨ë©ë‹ˆë‹¤.
router í•¨ìˆ˜ê°€ `END`ë¥¼ ë°˜í™˜í•˜ì˜€ê³  ê·¸ì— ë”°ë¼ graph stateëŠ” `END`nodeë¡œ ì´ë™í•˜ì˜€ê¸° ë•Œë¬¸ì—
êµ³ì´ ìš°ë¦¬ëŠ” `finish_point`ë¥¼ ëª…ì‹œí•  í•„ìš” ì—†ìŠµë‹ˆë‹¤.
graphëŠ” ì´ë¯¸ `finish_point`ê°€ êµ¬í˜„ë˜ì–´ìˆìŠµë‹ˆë‹¤.

ì´ì œ ìš°ë¦¬ê°€ ë§Œë“  graphë¥¼ ì‹œê°í™”í•´ë³´ë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤.
ì•„ë˜ ì½”ë“œì— ëŒ€í•´ì„œëŠ” ì‹¤í–‰ ì „ì— ì¶”ê°€ì ì¸ ì˜ì¡´ì„± íŒ¨í‚¤ì§€ ì„¤ì¹˜ê°€ í•„ìš”í•©ë‹ˆë‹¤.

```
from IPython.display import Image, display

try:
    display(Image(graph.get_graph().draw_mermaid_png()))
except Exception:
    # This requires some extra dependencies and is optional
    pass
```

![[Pasted image 20250430111717.png]]

ì´ì œëŠ” chatbotì—ê²Œ LLMì´ í•™ìŠµí•œ ë‚´ìš© ê·¸ ì´ìƒì˜ ì§ˆë¬¸ë„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```
while True: [](https://langchain-ai.github.io/langgraph/tutorials/introduction/#__codelineno-20-2)try: [](https://langchain-ai.github.io/langgraph/tutorials/introduction/#__codelineno-20-3)user_input = input("User: ") [](https://langchain-ai.github.io/langgraph/tutorials/introduction/#__codelineno-20-4)if user_input.lower() in ["quit", "exit", "q"]: [](https://langchain-ai.github.io/langgraph/tutorials/introduction/#__codelineno-20-5)print("Goodbye!") [](https://langchain-ai.github.io/langgraph/tutorials/introduction/#__codelineno-20-6)break [](https://langchain-ai.github.io/langgraph/tutorials/introduction/#__codelineno-20-7)[](https://langchain-ai.github.io/langgraph/tutorials/introduction/#__codelineno-20-8)stream_graph_updates(user_input) [](https://langchain-ai.github.io/langgraph/tutorials/introduction/#__codelineno-20-9)except: [](https://langchain-ai.github.io/langgraph/tutorials/introduction/#__codelineno-20-10)# fallback if input() is not available [](https://langchain-ai.github.io/langgraph/tutorials/introduction/#__codelineno-20-11)user_input = "What do you know about LangGraph?" [](https://langchain-ai.github.io/langgraph/tutorials/introduction/#__codelineno-20-12)print("User: " + user_input) [](https://langchain-ai.github.io/langgraph/tutorials/introduction/#__codelineno-20-13)stream_graph_updates(user_input) [](https://langchain-ai.github.io/langgraph/tutorials/introduction/#__codelineno-20-14)break
```

```
Assistant: [{'text': "To provide you with accurate and up-to-date information about LangGraph, I'll need to search for the latest details. Let me do that for you.", 'type': 'text'}, {'id': 'toolu_01Q588CszHaSvvP2MxRq9zRD', 'input': {'query': 'LangGraph AI tool information'}, 'name': 'tavily_search_results_json', 'type': 'tool_use'}]
Assistant: [{"url": "https://www.langchain.com/langgraph", "content": "LangGraph sets the foundation for how we can build and scale AI workloads \u2014 from conversational agents, complex task automation, to custom LLM-backed experiences that 'just work'. The next chapter in building complex production-ready features with LLMs is agentic, and with LangGraph and LangSmith, LangChain delivers an out-of-the-box solution ..."}, {"url": "https://github.com/langchain-ai/langgraph", "content": "Overview. LangGraph is a library for building stateful, multi-actor applications with LLMs, used to create agent and multi-agent workflows. Compared to other LLM frameworks, it offers these core benefits: cycles, controllability, and persistence. LangGraph allows you to define flows that involve cycles, essential for most agentic architectures ..."}]
Assistant: Based on the search results, I can provide you with information about LangGraph:

1. Purpose:
   LangGraph is a library designed for building stateful, multi-actor applications with Large Language Models (LLMs). It's particularly useful for creating agent and multi-agent workflows.

2. Developer:
   LangGraph is developed by LangChain, a company known for its tools and frameworks in the AI and LLM space.

3. Key Features:
   - Cycles: LangGraph allows the definition of flows that involve cycles, which is essential for most agentic architectures.
   - Controllability: It offers enhanced control over the application flow.
   - Persistence: The library provides ways to maintain state and persistence in LLM-based applications.

4. Use Cases:
   LangGraph can be used for various applications, including:
   - Conversational agents
   - Complex task automation
   - Custom LLM-backed experiences

5. Integration:
   LangGraph works in conjunction with LangSmith, another tool by LangChain, to provide an out-of-the-box solution for building complex, production-ready features with LLMs.

6. Significance:
   LangGraph is described as setting the foundation for building and scaling AI workloads. It's positioned as a key tool in the next chapter of LLM-based application development, particularly in the realm of agentic AI.

7. Availability:
   LangGraph is open-source and available on GitHub, which suggests that developers can access and contribute to its codebase.

8. Comparison to Other Frameworks:
   LangGraph is noted to offer unique benefits compared to other LLM frameworks, particularly in its ability to handle cycles, provide controllability, and maintain persistence.

LangGraph appears to be a significant tool in the evolving landscape of LLM-based application development, offering developers new ways to create more complex, stateful, and interactive AI systems.
Goodbye!
```

ì¶•í•˜í•©ë‹ˆë‹¤! 
LangGraphë¥¼ í†µí•´ í•„ìš”í•  ë•Œë§ˆë‹¤ ê²€ìƒ‰ ì—”ì§„ì„ í†µí•´ í•„ìš”í•œ ì •ë³´ë¥¼ ìƒì„±í•´ë‚´ëŠ” 
ëŒ€í™”í˜• agent êµ¬ì¶•ì— ì„±ê³µí•˜ì…¨ìŠµë‹ˆë‹¤.
ì´ì œ ì¡°ê¸ˆ ë” ë„“ì€ ë²”ìœ„ì˜ ì§ˆë¬¸ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤.
ë˜í•œ ì•ì„œ ì–¸ê¸‰í–ˆë˜ê²ƒì²˜ëŸ¼ agentì˜ ì‘ì—… ë‚´ìš© ë˜í•œ [LangSmith trace](https://smith.langchain.com/public/4fbd7636-25af-4638-9587-5a02fdbb0172/r)ë¥¼ í†µí•´ ì¶”ì ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.

ìš°ë¦¬ê°€ ë§Œë“  chatbotì€ ì—¬ì „íˆ ê³¼ê±° ìƒí˜¸ì‘ìš©í•œ ëŒ€í™”ì— ëŒ€í•´ì„œëŠ” ê¸°ì–µí•˜ì§€ ëª»í•©ë‹ˆë‹¤.
ë˜í•œ ì¼ê´€ì„± ìˆëŠ” ë‹µë³€ê³¼ multi-turn ëŒ€í™” ëŠ¥ë ¥ì´ ë¶€ì¡±í•©ë‹ˆë‹¤.
ì´í›„ íŒŒíŠ¸ì— ëŒ€í•´ì„œëŠ” **memory**ê¸°ëŠ¥ì„ ì¶”ê°€í•¨ìœ¼ë¡œì¨ ìœ„ ê¸°ëŠ¥ì„ ë³´ì™„í•´ë³´ë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤.

í•´ë‹¹ ì„¹ì…˜ì—ì„œ ë§Œë“  graphì˜ ì „ì²´ ì½”ë“œëŠ” ì•„ë˜ì™€ ê°™ìŠµë‹ˆë‹¤.
ìš°ë¦¬ê°€ êµ¬í˜„í•œ `BasicToolNode` ëŠ” [ToolNode](https://langchain-ai.github.io/langgraph/reference/prebuilt/#toolnode)ë¡œ ëŒ€ì²´ë˜ì—ˆìœ¼ë©°
`route_tools`ì¡°ê±´ ì—­ì‹œ [tools_condition](https://langchain-ai.github.io/langgraph/reference/prebuilt/#tools_condition)ìœ¼ë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.

### Full Code
API Reference: [init_chat_model](https://python.langchain.com/api_reference/langchain/chat_models/langchain.chat_models.base.init_chat_model.html) | [TavilySearch](https://python.langchain.com/api_reference/tavily/tavily_search/langchain_tavily.tavily_search.TavilySearch.html) | [BaseMessage](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.base.BaseMessage.html) | [StateGraph](https://langchain-ai.github.io/langgraph/reference/graphs/#langgraph.graph.state.StateGraph) | [add_messages](https://langchain-ai.github.io/langgraph/reference/graphs/#langgraph.graph.message.add_messages) | [ToolNode](https://langchain-ai.github.io/langgraph/reference/prebuilt/#langgraph.prebuilt.tool_node.ToolNode) | [tools_condition](https://langchain-ai.github.io/langgraph/reference/prebuilt/#langgraph.prebuilt.tool_node.tools_condition)
```
from typing import Annotated

from langchain.chat_models import init_chat_model
from langchain_tavily import TavilySearch
from langchain_core.messages import BaseMessage
from typing_extensions import TypedDict

from langgraph.graph import StateGraph
from langgraph.graph.message import add_messages
from langgraph.prebuilt import ToolNode, tools_condition


class State(TypedDict):
    messages: Annotated[list, add_messages]


graph_builder = StateGraph(State)


tool = TavilySearch(max_results=2)
tools = [tool]
llm = init_chat_model("anthropic:claude-3-5-sonnet-latest")
llm_with_tools = llm.bind_tools(tools)


def chatbot(state: State):
    return {"messages": [llm_with_tools.invoke(state["messages"])]}


graph_builder.add_node("chatbot", chatbot)

tool_node = ToolNode(tools=[tool])
graph_builder.add_node("tools", tool_node)

graph_builder.add_conditional_edges(
    "chatbot",
    tools_condition,
)
# Any time a tool is called, we return to the chatbot to decide the next step
graph_builder.add_edge("tools", "chatbot")
graph_builder.set_entry_point("chatbot")
graph = graph_builder.compile()
```


___

# Part 3: Chatbotì— Memory ê¸°ëŠ¥ ì¶”ê°€í•˜ê¸°

í˜„ì¬ ìš°ë¦¬ê°€ ë§Œë“  chatbotì€ ì‚¬ìš©ìì˜ ì§ˆë¬¸ì— ëŒ€í•´ `tools`ë¥¼ ì‚¬ìš©í•˜ì—¬ ë‹µë³€í•©ë‹ˆë‹¤.
í•˜ì§€ë§Œ, ê³¼ê±° ëŒ€í™”ì— ëŒ€í•œ ë§¥ë½ì„ ê¸°ì–µí•˜ì§„ ëª»í•©ë‹ˆë‹¤.
ê·¸ë ‡ê¸°ì— multi-turn ëŒ€í™”ì—ì„œ ì¼ê´€ì ì¸ ë‹µë³€ì„ í•˜ë„ë¡ í•˜ëŠ” ëŠ¥ë ¥ ë˜í•œ ì—†ìŠµë‹ˆë‹¤.

ì´ëŸ¬í•œ ë¬¸ì œë¥¼ LangGraphì—ì„œëŠ” ì§€ì†ì ì¸ `checkpointing`ì„ í†µí•´ í•´ê²°í•˜ì˜€ìŠµë‹ˆë‹¤.
graphë¥¼ complieí•  ë•Œ `checkpointer`ë¥¼ êµ¬í˜„í•˜ì˜€ë‹¤ë©´
ì´í›„ graphì—ì„œ `thread_id`ë¥¼ í†µí•´ ì´ì „ ëŒ€í™”ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ìˆìœ¼ë©°
ì´ë¡œ ì¸í•´ ê³¼ê±° í–ˆë˜ ëŒ€í™”ì˜ ì¤‘ë‹¨ì§€ì ì—ì„œë¶€í„° ë‹¤ì‹œê¸ˆ ëŒ€í™”ë¥¼ ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ë‹¨ìˆœí•œ chat memoryë³´ë‹¤ `checkpointing`ê¸°ëŠ¥ì´ í›¨ì”¬ ë” ê°•ë ¥í•˜ë‹¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆì„ ê²ƒì´ë©°,
ì´ ê¸°ëŠ¥ì€ ì—ëŸ¬ ë³µêµ¬, ì‚¬ìš©ì ê°œì… ê¸°ë°˜ workflow, 




`MemorySaver`checkpointer êµ¬í˜„ì„ ì‹œì‘í•´ë³´ë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤.

API Reference:Â [MemorySaver](https://langchain-ai.github.io/langgraph/reference/checkpoints/#langgraph.checkpoint.memory.MemorySaver)
```
from langgraph.checkpoint.memory import MemorySaver

memory = MemorySaver()
```
___

# end point