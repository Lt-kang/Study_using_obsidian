# SOLID 란?
- 객체지향 프로그래밍에서 "유지보수 쉽고, 확장 가능하며, 읽기 좋은 코드"를 작성하기 위한 원칙


# SOLID
## SRP: 단일 책임 원칙(Single Responsibility Principle)
- 정의: "클래스는 하나의 책임만 가져야 한다."
- 핵심: 한 클래스는 오직 하나의 변화 이유만 가져야 함
- 예시: 사용자 정보를 저장하고 클래스가 사용자 정보 저장"만" 하고, 화면 출력까지 책임지면 안 됨

## OCP: 개방-폐쇄 원칙(Open/Closed Principle)
- 정의: "소프트웨어 엔티티는 확장에는 열려 있고, 변경에는 닫혀 있어야 한다."
- 핵심: 새로운 기능 추가는 가능하지만, 기존 코드는 수정하지 않아야 함
- 예시: 새로운 결제 방식을 추가할 때 기존 결제 클래스는 건드리지 않고, 새로운 클래스를 추가하는 식

## LSP: 리스코프 치환 원칙(Liskov Substitution Principle)
- 정의: "자식 클래스는 언제나 부모 클래스를 대체할 수 있어야 한다."
- 핵심: 부모 타입 객체가 사용되는 곳에 자식 타입 객체를 넣어도 정상 동작 해야 함
- 예시: `Bird` 클래스를 상속한 `Penguin`이 날 수 없다면, `fly()`가 반드시 필요한 곳에서는 문제 발생

## ISP: 인터페이스 분리 원칙(Interface Segregation Principle)
- 정의: 클라이언트는 자신이 사용하지 않는 인터페이스에 의존하면 안 된다.
- 핵심: 큰 인터페이스보다는 여러 개의 작은 인터페이스로 분리
- 예시: 프린터 기능 인터페이스에 scan(), fax(), rpint()가 모두 있다면, "프린트만" 하는 기계도 모두 구현해야 해서 비효율 -> 인터페이스를 분리

## DIP: 의존 역전 원칙(Dependency Inversion Principle)
- 정의: 상위 모듈은 하위 모듈에 의존하면 안 되고, 둘 다 추상화(인터페이스)에 의존해야 한다.
- 핵심: 구현이 아닌 "추상화"에 의존해서 유연한 구조
- 예시: PaymentService가 CreditCard 클래스에 직접 의존하는 게 아니라, IPayment 인터페이스에 의존하도록 설계


# 요약
|약자|이름|한 줄 설명|
|---|---|---|
|SRP|단일 책임 원칙|한 클래스(모듈)는 오직 하나의 책임만 갖는다|
|OCP|개방-폐쇄 원칙|기존 코드는 수정 없이, 확장만으로 기능 추가|
|LSP|리스코프 치환 원칙|부모 타입 대신 자식 타입 써도 동작에 문제가 없어야 함|
|ISP|인터페이스 분리 원칙|필요 없는 기능에 강제 의존하지 않게, 인터페이스는 쪼개라|
|DIP|의존 역전 원칙|구체가 아니라 추상(인터페이스)에 의존하라|


# SOLID를 지켜야 하는 이유
- 코드 변경이 쉬움 (유지보수성)
- 새로운 기능 추가가 쉬움 (확장성)
- 테스트 코드 작성이 쉬움 (테스트 용이성)
- 의존성 분리 (유연한 구조)